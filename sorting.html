<html>
    <head>
        <title>Listen and visualize sorting algorithms</title>
        <meta property="og:title" content="Listen and visualize sorting algorithms">
        <meta name="author" content="Usama">
        <meta property="og:locale" content="en_US">
        <meta property="og:description" content="Sorting Algorithms with Sound">
        <meta property="og:image" content="https://smusamashah.github.io/VisualizingSorts/screenshot3.png">
        <meta property="og:type" content="demo">
        
        <meta name="google-site-verification" content="fcsy6xwzGDIwyzoNhlebWTJvbkmQNzPNwrpy0YpIqHI" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-8113893-21"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-8113893-21');
        </script>
    </head>
<body>
    <style>
        #container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            margin: 0;
        }
        #cvs {
            box-shadow: 0px -7px 300px 3px rgb(46, 46, 46);
        }
    </style>
    <a href="https://github.com/SMUsamaShah/VisualizingSorts" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    <div id="container">
        <canvas id="cvs" width="512" height="512"></canvas>
        <div id="algonames"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.js"></script>
    <script src="./util.js"></script>
    <script src="./algos.js"></script>
    <script type="text/javascript">
        var wizSorting = new WizSorting();
        var gui = new dat.GUI();
        gui.add(wizSorting, 'audio').name("Sound");
        gui.add(wizSorting, 'arraySize', 8, 512, 8).name("Size");
        gui.add(wizSorting, 'stepDelay', 1, 1000, 1).name("Delay(ms)");
        gui.add(wizSorting, 'detail', 1, 3, 1).name("Detail");

        gui.add(wizSorting, 'color_map', Object.keys(wizSorting.color_maps)).name("Color Scheme");

        // list all algos
        wizSorting.algos.forEach((v, i)=>{
            gui.add(wizSorting.algos[i], 'enabled').name(v.name);
        });

        gui.add(wizSorting, 'main').name("Start");
        gui.add(wizSorting, 'stop').name("Stop");
        //wizSorting.main();

        function WizSorting() {
            var _this = this; // damn callbacks
            var MAX_GRID_SIZE = 512; // even this is too slow

            this.audio = false;
            this.ph = 8; // point height
            this.pw = 8; // point width
            this.arraySize = 128;
            this.stepDelay = 10;
            this.max = this.arraySize;
            this.detail = 3;
            this.color_map = 'magma';
            let reset = true;
            let repeatCount = 0;

            // functions
            this.main = main;
            this.stop = stop;
            this.onSortsFinished = onAllSortingFinished;

            this.algos = [
                { name: "Bubble Sort", fn: bubbleSort, enabled: false },
                { name: "Cocktail Sort", fn: cocktailSort, enabled: false },
                { name: "Insertion Sort", fn: insertionSort, enabled: false },
                { name: "Gnome Sort", fn: gnomeSort, enabled: false },
                { name: "Comb Sort", fn: combSort, enabled: false },
                { name: "Shell Sort", fn: shellSort, enabled: false },
                { name: "Selection Sort", fn: selectionSort, enabled: false },
                { name: "Merge Sort", fn: mergeSort, enabled: false },
                { name: "Parallel Merge Sort", fn: parallelMergeSort, enabled: false },
                { name: "Radix Sort", fn: radixSort, enabled: false },
                { name: "Quick Sort", fn: quickSort, enabled: false },
                { name: "Odd-Even Sort", fn: oddEvenSort, enabled: false },
                { name: "Cycle Sort", fn: cycleSort, enabled: false },
                { name: "Heap Sort", fn: heapSort, enabled: false },
                // _this.oddEvenSort2 ? Sorting.oddEvenSort2 : null,
            ];

            var audioCtx;
            var _ctx, ctx;
            var _canvas, offCanvas; // offscreen canvas for faster rendering

            this.color_maps = {
                hsl: function (x, max) {
                    let j = rescale(x, 0, max, 0, 360);
                    return "hsl(" + (j) + ", 50%, 50%)";
                },
                grayscale: function (x, max) {
                    let j = rescale(x, 0, max, 0, 255);
                    return 'rgb(' + [j, j, j].join() + ')';
                },
                magma: function (x, max) {
                    let j = rescale(x, 0, max, 0, 360);
                    return `hsl(${j * 0.5 + 250},${50}%,${50 * j / 180}%)`;
                }
            };

            // init
            (function () {
                audioCtx = new AudioContext();
                _canvas = document.getElementById("cvs");
                _canvas.setAttribute("width", MAX_GRID_SIZE);
                _canvas.setAttribute("height", MAX_GRID_SIZE);
                _ctx = _canvas.getContext("2d", { alpha: false }); // on screen context

                // everything will be rendered on this off-screen canvas
                offCanvas = new OffscreenCanvas(MAX_GRID_SIZE, MAX_GRID_SIZE);
                ctx = offCanvas.getContext('2d');
                // and will be copied to on-screen canvas in requestAnimationFrame

                _this.ph = _this.pw = MAX_GRID_SIZE / _this.arraySize;

                for (let i = 0; i < _this.arraySize; i++) {
                    drawPoint(i, 0, i * _this.ph, MAX_GRID_SIZE, _this.ph)
                }
            })();
            
            function renderLoop() {
                // let bitmap = offCanvas.transferToImageBitmap();
                // _ctx.transferFromImageBitmap(bitmap);
                
                _ctx.drawImage(ctx.canvas, 0, 0);
                requestAnimationFrame(renderLoop);
            }
            renderLoop();

            // var recorder = new CanvasRecorder(_canvas);

            function main() {
                reset = true;
                _this.max = _this.arraySize;
                _this.ph = _this.pw = MAX_GRID_SIZE / _this.arraySize;

                // recorder.start();

                reset = false;
                let numbers = (new Int32Array(_this.arraySize))
                    .fill(0, 0, _this.arraySize)
                    .map(function (v, i) { return i + 1; });

                // selected sorts
                let selectedAlgos = _this.algos.filter(v => v.enabled == true);
                if (selectedAlgos.length == 0) {
                    return;
                }

                // algo labels
                let el = document.getElementById("algonames");
                if (el) {
                    el.innerText = "";
                    selectedAlgos.forEach((sort, i) => {
                        el.innerText += sort.name;
                        if (i < selectedAlgos.length - 1)
                            el.innerText += " |  ";
                    });
                }

                repeatCount = Math.ceil(_this.arraySize / selectedAlgos.length);

                // create arrays for algos filled with randomized data
                let arrays = new Array(selectedAlgos.length * repeatCount);
                for (let i = 0; i < arrays.length; i++) {
                    arrays[i] = shuffle(numbers).slice(); // shuffled.slice();
                    drawArray(arrays[i], i);
                }

                // run algos by applying selected algo on each array
                console.time("algorun");
                let calls = [];
                let x = 0;
                for (let i = 0; i < selectedAlgos.length; i++) {
                    for (let j = 0; j < repeatCount; j++) {
                        const sortingAlgo = selectedAlgos[i].fn;
                        if (sortingAlgo != null)
                            var c = sortingAlgo(arrays[x], drawcb(x++));
                            calls.push(c);
                    }
                }

                Promise.all(calls).then((values)=>{
                    _this.onSortsFinished(values);
                });
            }

            function drawcb(x) {
                return async function draw_and_wait(arr, detail = 1, ...indexes) {
                    if (_this.detail != detail) return;

                    // draw given indexes of array
                    if (arguments.length <= 2) {
                        // draw whole array if no indexes specified
                        drawArray(arr, x);
                    } else {
                        // otherwise draw given index only
                        for (let i = 0; i < indexes.length; i++) {
                            const j = indexes[i];
                            drawPoint(arr[j], x * _this.pw, j * _this.ph, _this.pw, _this.ph);

                            // // play the music
                            // if (x === 0 && _this.audio) {
                            //     playAudio(j, 1.7);
                            // }
                        }
                    }

                    // wait after drawing
                    await sleep(_this.stepDelay);
                }
            }

            function stop () {
                // if(_this.audio && osc) osc.stop();
                if(reset == false) {
                    reset = true;
                }
            }

            function onAllSortingFinished(e){
                // console.log("Finished", e);
                // recorder.stop();
                // recorder.save();
                console.timeEnd("algorun");
            }

            function playAudio(freq, time = 1.5) {
                let osc = audioCtx.createOscillator();
                let gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';

                osc.frequency.value = 500 + freq * 7;
                osc.start(); // play sound
                gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + time); // reduce it gradually
                setTimeout(() => osc.stop(), 300);
                //o.stop();
            }

            // setTimeout.dt = 0;
            // function selfAdjustingTimeout(callback, timeout, args) {
            //     setTimeout.et = (new Date).getTime() + timeout;
            //     let cb = () => {
            //         setTimeout.dt = (new Date).getTime() - setTimeout.et;
            //         callback();
            //     };

            //     setTimeout(cb, timeout - setTimeout.dt, args);
            // }

            async function sleep(ms) {
                if (reset)
                    return Promise.reject("stopped");
                // return new Promise(rs => selfAdjustingTimeout(rs, ms));
                return new Promise(rs => setTimeout(rs, ms));
            }

            // draw array on position x
            function drawArray(arr, x) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    drawPoint(arr[i], x * _this.pw, i * _this.ph, _this.pw, _this.ph);
                }
            }

            // draw number as HSL block with constant saturation and luminence
            function drawPoint(hue, x, y, w, h, highlight = false) {
                let j = rescale(hue, 0, _this.max, 0, 360);
                ctx.fillStyle = _this.color_maps[_this.color_map](hue, _this.max); 
                ctx.fillRect(x, y, w, h);
            }
        }
    </script>
</body>

</html>
